#include <stdio.h> // Стандартная библиотека ввода/вывода итд stdio.h
#include <stdlib.h> // Подключение библиотеки stdlib.h
#include <math.h> // Библиотека с математическими функциями math.h, для работы некоторых функций нужно компилировать с ключом -lm
#include <time.h> // Подключение библиотеки time.h

double method_1(int, double, double, double, double, double); // Прототип функции вычисляющей корни по заданному методу
double method_2(int, double, double, double, double); // Прототип функции вычисляющей корни по заданному методу
double f(int, double, double, double); // Прототип функции, возвращающей результаты уравнения
double df(int, double, double, double); // Прототип функции, возвращающей значение производной функции в данной точке
void inputAndFails(int *, int *, double *, double *, double *, double *, double *, double *); // Прототип функции, в которой осуществляется ввод данных и проверка их на ошибки 

// Функция main() выполняется при старте программы
main(){
  srand(time(NULL)); // Генерация случайных чисел будет зависеть от времени
  // Объявление переменных типа int для выбора метода и уравнения
  // и типа float, содержащих значения, необходимые для вычислений
  int findMethod, eqNum;
  double k1, k2, E, a, b, result, xn;

  // Запуск функции inputAndFails() с ссылками на переменные, объявленные ранее, чтобы она могла их менять
  inputAndFails(&findMethod, &eqNum, &k1, &k2, &E, &a, &b, &xn);
  // Если пользователь выбрал метод 1, то присваивает значение, возвращаемое функцией method_1, переменной result
  // В ином случае присваивает переменной result значение, возвращаемое функцией method_2() 
  if(findMethod == 1)
    result = method_1(eqNum, k1, k2, E, a, b);
  else 
    result = method_2(eqNum, k1, k2, E, xn);
  // Выводит результат
  printf("x = %f\n",result);
  // Возвращает значение 0, используется как проверка на ошибки
  return 0;  
}

// Функция, возвращающая значение, полученное с помощью 1 метода (либо -1 в случае слишком большого количества итераций)
double method_1(int eN, double k1, double k2, double E, double a, double b){
  // Объявление локальных переменных типа double
  double c, fc,fa;
  // Объявление локальной переменной iter и присвоение ей значения 0
  int iter=0;
  // Цикл do{}while() выполняется минимум 1 раз, а затем пока выполняется условие
  do{
    // Формула получения точки "с"
    c=(a+b)/2;
    // Если с равно а или b, то цикл прерывается
    if(c == a || c == b)
      break;

    // переменным fc и fa присваивается значение функции в точках c и a соответственно
    fc=f(eN, k1, k2, c);
    fa=f(eN, k1, k2, a);
    // Если fc и fa >= 0 или fc и fa <= 0, a=c, в противном случае b=c
    if(fc>=0 && fa>=0 || fc<=0 && fa<=0)
      a=c;
    else
      b=c; 
    iter++; // Счётчик итераций
    // Если проходит слишком много итераций, функция завершается со значением -1
    if(iter==200)
      return -1;
  } while(fabs(b-a) > E); // Условие цикла: |b-a| > E
  // Выводит число итераций
  printf("iter = %d\n", iter);
  // Возвращает значение с
  return c;
}

// Функция, возвращающая значение, полученное с помощью 2 метода (либо -1 в случае слишком большого количества итераций)
double method_2(int eqNum, double k1, double k2, double E, double xn){
  // Объявление локальных переменных типа double
  double ifEnd, x,rx[3];
  // Объявление локальной переменной iter и присвоение ей значения 0
  int iter=0;
  
  do{
    // Формула получения точки х
    x = xn - f(eqNum, k1, k2, xn)/df(eqNum, k1, k2, xn);

    // массив rx состоит из значений, используемых в if, чтобы if выглядел читаемо
    rx[0]=fabs(x-xn);
    rx[1]=fabs(f(eqNum, k1, k2, xn-E));
    rx[2]=fabs(f(eqNum, k1, k2, xn+E));
    // Проверяется условие конца цикла и в случае необходимости (если одинаковые знаки на концах отрезка), E уменьшается
    if(rx[0]<E && ((rx[1]>0 && rx[2]>0) || (rx[1]<0 && rx[2]<0)))
      E/=10;
    // Если проходит слишком много итераций, функция завершается со значением -1
    if(iter==200)
      return -1;
    // присваивает переменной xn значение переменной x
    xn=x;
    iter++; // Счётчик итераций
    
  }while(rx[0]>E); // Условие цикла |x-xn|>E
  // Выводит число итераций
  printf("iter = %d\n", iter);
  // Возвращает значение с
  return x;
}

// Функция, возвращающее значение производной в данной точке для нужной функции
double df(int eqNum, double k1, double k2, double x){
  // Опретор switch обрабатывает несколько случаев - при разных значениях eqNum будут выполнятся  разные действия
  switch(eqNum){
    // Если eqNum == 1, то возвращается значение производной в точке первой функции
  case 1:
    return 1/(x*logf(2));
  case 2:
    return 4*powf(x,3)+k1*3*x*x-k2;
  case 3:  
    return 5*powf(x,4)+2*k1*x;
  case 4:
    return 2*x+k1;
  case 5:
    return 2/(x*logf(2));
  case 6:
    return 3*x*x+k1;
  }
}
// Функция, возвращающее значение выбранной функции в данной точке
double f(int eqNum, double k1, double k2, double x){
  
  switch(eqNum){
    // Если eqNum == 1, то возвращается значение функции в точке первой функции
  case 1:
    return log2f(k1*x) - k2;
  case 2:
    return powf(x,4) + k1*powf(x,3) - k2*x;
  case 3:
    return powf(x,5) + k1*powf(x,2) - k2;
  case 4:
    return powf(x, 2) + k1*x + k2;
  case 5:
    return log2f(x*x*k1) + k2;
  case 6:
    return powf(x,3)+k1*x+k2;
  }
  
}

// Функция, отвечающая за ввод данных пользователем
void inputAndFails(int *fM, int *eN, double *k1, double *k2, double *E, double *a, double *b, double *xn){
  // Объявление локальных переменных типа double
  double cache,fa,fb;
  // Предлагает пользователю выбрать метод и считывает введённые им данные
  printf("Введите номер способа, которым хотите решить это уравнение (1, 2)\n");
  scanf("%d", fM);
  // Если пользователь ввёл неверные данные, то метод выбирается случайным образом
  if(*fM!=1 && *fM!=2){
    printf("Неверный номер, будет сгенерирован случайный\n");
    *fM = rand()%2+1; // Присвоение переменной fM случайного значения от 1 до 2
    printf("Способ %d\n", *fM);
  }
  
  // Выбор уравнения
  printf("Введите номер уравнения (1, 2, 3 - уравнения 3, 5, 6 из заданий соответсвенно\n4, 5, 6 - мои уравнения)\n");
  scanf("%d", eN);
  // Если пользователь ввёл неверные данные, то уравнение выбирается случайным образом
  if(*eN<1 || *eN>6){
    printf("Неверный номер, будет сгенерирован случайный\n");
    *eN = rand()%6+1; // переменной o присваивается случайное значение от 1 до 6 вклюичтельно
    printf("Будет решаться уравнение %d\n", *eN);
  }

  // Ввод k1
  while(1){ // Бесконечный цикл
    printf("Введите коэфиценты уравнение\n k1 = "); // Вывод строкт
    scanf("%lf", k1); // Ввод числа с плавающей точкой с клавиатуры
    if(*k1==0 && (*eN==1 || *eN == 5)){ // Если пользователеь ввёл неверно k1, выводит сообщение об ошибке
      printf("k1 не может равняться 0\n");
    }
    else // Если к1 введено правильно, цикл прерывается 
      break;
  }
  // Ввод k2
  printf(" k2 = "); // Вывод строки
  scanf("%lf", k2); // Ввод с клавиатуры
  
  // Ввод E
  printf("Введите точность решения уравнение E\n E = ");
  scanf("%lf", E);
  *E = fabs(*E); // На случай, если будет введено E<0

  // Ввод a, b или xn, в зависимости от метода
  if(*fM == 2){ // Если 2 метод - то вводится xn
    printf("Введите xn\n");
    scanf("%lf", xn);
  } else { // Если 1 метод - вводится a и b
    // Бесконечный цикл
    while(1){
      // Ввод a и b
      printf("Введите a и b\n a = ");
      scanf("%lf", a);
      printf(" b = ");
      scanf("%lf", b);

      // Если a > b, то меняю их местами
      if(*a > *b){
	cache = *a;
	*a = *b;
	*b = cache;
      }

      // Если выбрано уравнение 1 или 5, то проверяется случай, когда введены a и b в местах, где функция не существует
      if((*eN == 1 || *eN == 5) && (*k1<0 && (*a>=0 || *b>=0) || *k1>0 && (*a<=0 || *b<=0))){
	printf("Должно соблюдаться условие:\nЕсли к1 < 0, a и б < 0\nЕсли к1 > 0, то а и б > 0\n");
	continue; // Переходит к следующей итерации цикла без выполнения строк ниже
      }
      // Если a == b, запускается новая итерация цикла
      if(*a == *b){
	printf("Они не могут быть равны\b");
	continue;
      }
      // Локальным переменным fa и fb присваивается значение функции в точках a и b соответсвенно, чтобы if был читаемей
      fa=f(*eN, *k1, *k2, *a);
      fb=f(*eN, *k1, *k2, *b);
      if((fa > 0 && fb > 0) || (fa < 0 && fb < 0)){ // Если fa и fb имеют один знак, то переходит к следующей итерации цикла
	printf("Неподходящие а, b, либо уравнение не имеет решений\n");
	continue;
      }

      break; // Прерывает цикл
  }
 }

}
